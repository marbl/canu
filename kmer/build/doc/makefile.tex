\documentclass[letterpaper]{article}

\usepackage{fullpage}

\begin{document}

\section{Overview of the proposed new IR build system}

The proposed buld system for IR projects is defined by the set of
file under \verb+cds/IR/build+.  These files consist of a \verb+Makefile+
and several ancillary files which provide platform specific and file
type specific definitions and rules.

The build itself is always directed through the one \verb+Makefile+ in
the build directory.  What I describe hereafter as {\em the build} is
really \verb+gmake+ is invoked with this \verb+Makefile+, either from
withing the \verb+cds/IR/build+ directory or referrenced explicitly
with a \verb+-f+ option to \verb+gmake+.

When the build is started, the ancillary files are examined to
establish definitions (and to provide a naming utility).  The build
then looks for a file named \verb+Make.include+ in the directory of
invocation.  This \verb+Make.include+ files should contain build
information for files pertinent to its directory and possible
inclusions of other \verb+Make.include+ files in lower directories.
Only after the tree of \verb+Make.include+'s is read that any building
starts, so that full dependency information is available before any
execution.

Additional include files which were defined in the \verb+Make.include+
files, such as the \verb+*.d+ files which typically hold C and C++
dependencies are included, possible after being rebuilt if a build
rule exists for them and they do not exist or are out of date.  Thus,
the first phase of the build is typically the creation of automatically
generated dependency information, with subsequent modifications of
sources minimally rebuilding these files.

The build properly proceeds with the creation of all targets which
have been defined.  Targets declared by placing them on the lists of
variables which are defined to be targets by the build rules.  It
is possible to subgoal the building at a file or directory level of
granularity.

\section{Invoking the build system}

There are two different directories which are of importance in the
build system.  The first is the fixed build directory, \verb+cds/IR/build/+,
which holds the \verb+Makefile+, ancillary files, and the installed files.
The second directory of important is the directory of invocation, the
place where \verb+gmake+ is executed.  These two directories coincide when
one executes \verb+gmake+ from the build directory.  It is important to
keep these things distinct because all actions take place in the directory
of invocation, but the build directory.

The first \verb+Make.include+ is read in the directory of invocation.
If the convention has been followed of having \verb+Make.include+
files in every node of the source tree which refer only to
subdirectories, then only those \verb+Make.include+ files at the
directory of invocation and lower will be read into the build system.
This means that automatic rebuilding of dependencies external to the
directory of invocation will not be handled fully (files will not be
updated, but they will be found if they exist).  Thus, if one wishes
to focus one's attention to a single subdirectory to build in, one
should make the subdirectory the directory of invocation.
\begin{verbatim}
$ cd that/subdir/
$ gmake -f ${cvs}/cds/IR/build/Makefile all
\end{verbatim}
This will result in much less work the build will have to do in
figuring out what actions to take, because it will examine fewer
constraints.

On the other hand, if one invokes from a higher directory, then
any sibling dependencies of the target will be properly updated.
\begin{verbatim}
$ cd ${cvs}/cds/IR/build
$ gmake that/subdir/.all
\end{verbatim}
This will result in all the the subgoals in a subdirectory (and lower)
being built, with any necessary updates of other directories being
handled automatically.  All rules which can be found are examined
although only those actions necessary for the given subtarget(s) are
taken.

By default, the build system builds all things under the
\verb+${cvs}/cds/IR+ tree which are currently checked out and which
support the build system by providing \verb+Make.include+ files.
\begin{verbatim}
$ cd ${cvs}/cds/IR/build
$ gmake
\end{verbatim}

The targets currently supported by the build system are\\
\begin{tabular}{ll}
\verb+all+ & build all subgoals\\
\verb+clean+ & remove subgoals\\
\verb+depends-clean+ & remove any automatically generated dependency (\verb+*.d+)files\\
\verb+real-clean+ & do both \verb+depends-clean+ and \verb+clean+\\
\verb+install+ & do all and copy subgoals and other files to the install subdirectory of the build directory\\
\verb+ls+ & do '\verb+ls -l+' of subgoals\\
\end{tabular}\\
These targets are also supported in a subtarget specific form, such as
\verb+that/subdir/.install+.

The compile options can be modified for debugging, profiling, or
compile with GNU compilers, or modifying the installation directory.\\
\begin{tabular}{ll}
\verb+WITH_OPT=debug+ & compile with no optimization and maximum debugging\\
\verb+WITH_OPT=profile+ & compile for profiling with optimization and minimal debugging\\
\verb+WITH_GNU=1+ & compile with gnu compilers\\
\verb+INSTALL_TAG=<foo>+ & append \verb+-<foo>+ to the name of the install directory\\
\verb+MAKE_COMPILERS=<foo>+ & use the file \verb+<foo>+ in place of \verb+Make.compilers+ (this option is of dubious value).
\verb+WITHOUT='dir1/ dir2/' & cancel the inclusion of any \verb+Make.include+ files in the given directories (another dubious option).
\end{tabular}\\
These options go on the \verb+gmake+ command line.
\begin{verbatim}
$ gmake WITH_OPT=debug WITH_GNU=1 INSTALL_TAG=release all
\end{verbatim}

\section{Anatomy of a Make.include}

\verb+Make.include+ files defined variables, and they are not
necessarily sitting in the same place where the build is invoked.  For
these two considerations, there is defined, for each
\verb+Make.include+ file a variable named by the single character
'\verb+/+' which holds the relative path of the current directory.
Any file in the current directory can be referenced by prepending
\verb+$/+ to it.  The contents of \verb+/+ ought to be unique in the
namespace of the build, so any variable defined as \verb+$/.MYVAR+
cannot conflict with any other variables in the build namespace (using
the syntax of hidden files for variables may be a bad thing, but it
has not caused problems yet).

So, a simple \verb+Make.include+ might look like:
\begin{verbatim}
$/.C_SRCS := $/hello.c
$/.C_EXES := $/hello
$/hello: $/hello.o
\end{verbatim}

Note the use of the 'verb+:=+' assignment instead of the '\verb+=+'
assignment.  The reason for this, is that \verb+gmake+ has two {\em flavors}
of variable, one which traditionally is lazily evaluated, defined by
'\verb+=+', and one which is imediately evaluated, defined by '\verb+:=+'.
If the RHS of the \verb+$/.C_SRCS+ assignment were to be lazily
evaluated, then the \verb+$/+ component of the name would expand to
whatever value \verb+/+ holds at the end of the whole traversal
(which is an empty string if everything goes right).  This would
produce errors.  I recommend the use of '\verb+:=+' in just about
every possible case, unless you are trying to be tricky on purpose.

There are a number of special variables, used on a per-\verb+/+
basis by the \verb+Make.rules+ ancillary file.  These variables can
be defined by the \verb+Make.include+ files to specify the various
types of files and the actions required to build them.  The current
list of variables is as follows:\\
\begin{tabular}{ll}
\verb+$/.C_SRCS+ & C sources which need to have their dependencies analyzed\\
\verb+$/.C_INCS+ & C header files\\
\verb+$/.C_LIBS+ & C library subgoals\\
\verb+$/.C_SHLIBS+ & C shared library subgoals\\
\verb+$/.C_EXES+ & C program subgoals\\
\verb+$/.CXX_<x>+ & same as \verb+$/.C_<x>+ but for C++\\
\verb+$/.TEX_PS+ & Postscript subgoals to be built from \LaTeX files\\
\verb+$/.TEX_PDF+ & PDF subgoals to be built from \LaTeX files\\
\verb+$/.PERL_LIBS+ & Perl script libraries\\
\verb+$/.PERL_EXES+ & Perl script executables\\
\verb+$/.PY_LIBS+ & Python script libraries\\
\verb+$/.PY_EXES+ & Python script executables\\
\verb+$/.LIB/+  & subdirectory of \verb+lib/+ where \verb+$/.C_LIBS+ and \verb+$/.CXX_LIBS+ are installed\\
\verb+$/.INCLUDE/+  & subdirectory of \verb+include/+ where \verb+$/.C_INCS+ and \verb+$/.CXX_INCS+ are installed\\
\verb+$/.DOC/+  & subdirectory of \verb+doc/+ where \verb+$/.TEX_PS+ and \verb+$/.TEX_PDF+ are installed\\
\verb+$/.PY_LIB/+  & subdirectory of \verb+scripts/+ where \verb+$/.PY_LIBS+ are installed\\
\verb+$/.PERL_LIB/+  & subdirectory of \verb+scripts/+ where \verb+$/.PERL_LIBS+ are installed\\
\verb+$/.CLEAN+ & files and patterns to be removed during a \verb+clean+\\
\verb+$/.REAL-CLEAN+ & files and patterns to be removed during a \verb+real-clean+\\
\end{tabular}\\
Note: while the current build system removes all subgoals, intermediate
files are not removed automatically.  If C/C++ programs are being build
then patterns like \verb+$/*.o+ should be put in the \verb+$/.CLEAN+ variable
or they will not get removed.  It is debatable whether this should be left
up to each \verb+Make.include+ file to take care of on its own.

There are a couple of routine tasks which are done a little
differently.  One of these tasks is the specification of additional
flags used when building the C/C++ programs.  For C programs, this is
done by adding to the \verb+CFLAGS+ variable in a target specific
manner.
\begin{verbatim}
$/myprogram.o $/myprogram.c.d: CFLAGS += -DTEST -I/usr/local/lib
\end{verbatim}
If you wish to have this take effect for all files defined in the
current \verb+Make.include+ you can use a pattern rule.
\begin{verbatim}
$/%.o $/%.d: CFLAGS +=-DTEST -I/usr/local/lib
\end{verbatim}
One {\em gotcha} comes in the use of locally defined variables
(like anything involving \verb+$/+).  It seems
that any variable expansion on the target specific '+=' is
delayed until after all rules have been traversed, at which point
\verb+$/+ is very likely to have the wrong value.  This does not
happen with a target specific '\verb+:=+' so it may be a bug in what is
a fairly new \verb+gmake+ feature.  The work around invokes another
fairly new \verb+gmake+ feature.
\begin{verbatim}
$(eval $/%.o $/%.d: CFLAGS +=-I$/include)
\end{verbatim}

The second routine task is that of specifying external libraries to
link to when building C/C++ executables.  If the libraries are
external to the whole build, then one would use the usual \verb+-L-l+
flags in a target specific variable modification.
\begin{verbatim}
$/myprogram: CLDFLAGS+=-L/usr/local/foodir
$/myprogram: CLIBS +=-lfoo
\end{verbatim}
One must again wrap any variable expressions which are likely to change
values with \verb+$(eval )+ to force variable expansion.  If the
library is within the build system, using the \verb+-L-l+ flags would
create a {\em dependency leak} as the build system would have no
way of knowing that the library must be updated before the link.
To avoid creating this leak, one should do the more explicit dependency.
\begin{verbatim}
$/myprogram: ${THELIBDIR/}libfoo.a
\end{verbatim}
Here no variable expansion needs to be forced, since dependency lines
do expand variables imediately.  By making it a dependent, \verb+libfoo.a+
will appear in the series of arguments to the linker for \verb+$/myprogram+
in addition to avoiding the leak.

\subsection{Two examples}

Here is a walkthrough of the \verb+Make.include+ for
\verb+AtacPipeline+, which builds a variety of executables and
libraries.

\begin{verbatim}
$/.CXX_EXES :=$/heavyChains

$/.CXX_SHLIBS :=$/localAlignerInterfacemodule.so $/halignmodule.so $/hellomodule.so
\end{verbatim}
One program and three shared libraries are subgoals to be created.

\begin{verbatim}
$/.CXX_SRCS:=$/GF_ALN_dpaligner.cc $/GF_ALN_local.cc \
  $/GF_ALN_overlap.cc $/GF_ALN_qvaligner.cc \
  $/GF_ALN_loverlapper.cc $/GF_ALN_pieceOlap.cc \
  $/halign.cc $/halignDriver.cc $/halignmodule.cc \
  $/heavyChains.cc \
  $/localAlignerInterface.cc $/localAlignerInterfacemodule.cc \
  $/hellomodule.cc $/byemodule.cc $/holignmodule.cc
\end{varbatim}
The source files are declared.

\begin{verbatim}
$/.CLEAN  := $/*.o $/*.pyc
\end{verbatim}
Since this directory will build both C++ programs and python programs,
intermediates for both must be \verb+clean+-ed.

\begin{verbatim}
$/.PY_EXES :=$/AtacDriver.py
$/.PY_LIBS :=$(filter-out ${$/.PY_EXES},$(wildcard $/*.py))
\end{verbatim}
A python executable is declared and the python libraries are any file in
this directory ending in '.py' which is not on the list of executables.
\begin{verbatim}
$/.PY_LIB/ :=AtacPipeline/
\end{verbatim}
The python libraries are to be installed under \verb+scripts/AtacPipeline+.

\begin{verbatim}
$/heavyChains   :  $/heavyChains.o

$/localAlignerInterfacemodule.so : \
   $/localAlignerInterfacemodule.o $/localAlignerInterface.o \
   $/GF_ALN_overlap.o $/GF_ALN_local.o \
   $/GF_ALN_loverlapper.o $/GF_ALN_pieceOlap.o \
   $/GF_ALN_dpaligner.o $/GF_ALN_qvaligner.o

$/hellomodule.so: $/hellomodule.o

$/halignmodule.so: $/halignmodule.o $/halign.o
\end{verbatim}
The linking dependencies for each of the targets is specified.

\begin{verbatim}
$(eval $/%.d $/%.o: CXXFLAGS+=${PYINC})
\end{verbatim}
The shared libraries being built are actually python extensions, so they
will be including python header files.  The \verb+${PYINC}+ path is
specified in the \verb+Make.compilers+ directory and is not expected to
change (so the \verb+$(eval )+ wrapper is a bit paranoid, but harmless).

There are some extra flags which are needed for building python
extensions at the end of this file when on AIX, but they are very
exceptional, and an explanation of there here is of little value.
\begin{verbatim}
$(eval $/localAlignerInterfacemodule.so: AIX_SHLIB_FLAGS+=-einitlocalAlignerInterface -Wl,-bI:$/AIX_python-module-exports)
$(eval $/halignmodule.so: AIX_SHLIB_FLAGS+=-einithalign -Wl,-bI:$/AIX_python-module-exports)
$(eval $/hellomodule.so: AIX_SHLIB_FLAGS+=-einithello -Wl,-bI:$/AIX_python-module-exports)
\end{verbatim}

Our next example is the \verb+Make.include+ for
\verb+MatchExtender+ which builds a series of C++ programs which
depend on external libraries.

\begin{verbatim}
FRAMEWORK/  :=$(call MakePath,$/../Framework/)
RASCAL/     :=$(call MakePath,$/../../../RASCAL/src/)
\end{verbatim}
External paths are defined by the \verb+MakePath+ function.  This
function is explained later.

\begin{verbatim}
$/.CXX_EXES := $/testFastaReader $/MatchExtender $/MismatchCounter
\end{verbatim}
Three C++ programs are to be built.

\begin{verbatim}
ind_src  := $/IndexedFastaReader.cc
test_src := $/testFastaReader.cc
mch_src  := $/MEMatch.cc
me_src   := $/MatchExtenderAtac.cc $/MatchExtender.cc
mc_src   := $/MismatchCounterAtac.cc $/MismatchCounter.cc

$/.CXX_SRCS := ${ind_src} ${test_src} ${mch_src} ${me_src}
\end{verbatim}
The sources are partitioned into four groups.

\begin{verbatim}
$/.CLEAN :=$/*.o $/*~ $/core
\end{verbatim}
On a \verb+clean+ we remove object files, emacs backups, and any cores.

\begin{verbatim}
$/testFastaReader: ${ind_src:.cc=.o} ${test_src:.cc=.o}
$/MatchExtender:   ${ind_src:.cc=.o} ${mch_src:.cc=.o} ${me_src:.cc=.o} 
$/MismatchCounter:   ${ind_src:.cc=.o} ${mch_src:.cc=.o} ${mc_src:.cc=.o} 
\end{verbatim}
Program dependencies are defined as combinations of the various
groups defined above, with their '.cc' extensions turned to '.o'.

\begin{verbatim}
${$/.CXX_EXES}: \
  ${RASCAL/}seq/libRASCAL_seq.a ${RASCAL/}base/libRASCAL_base.a \
  ${FRAMEWORK/}libATAC.a

$(eval $/%.d $/%.o:   CXXFLAGS+=-I${RASCAL/}. -I${FRAMEWORK/}.)
\end{verbatim}
All programs must link to several external libraries and use their
header files.

\subsection{The Include function}

The build system has wrapped the usual \verb+include+ syntax of
\verb+gmake+ with a function called \verb+Include+ which can be
invoked from within a \verb+Make.include+ file.
\begin{verbatim}
$(eval $(call Include,$/subdir1/ $/subdir2/))
\end{verbatim}
Its effect is to check if there exists a \verb+Make.include+ file
in any of its directory arguments, and if so, to add that file to
the set of \verb+Make.include+ files which will be traversed.
The contents of those \verb+Make.include+ files are evaluated
and added to the current build definitions.  \verb+/+ is pushed
and popped appropriately.

\subsection{The MakePath function}

The build system supplies a function \verb+MakePath+ which is
meant to be called in \verb+Make.include+ files to canonicalize pathnames.
The problem is addresses is one of \verb+gmake+'s inability to recognize
the sameness of expressions like \verb+src/../src/foo+ and \verb+src/foo+.
Suppose we had a set of files and directories as follows:
\begin{verbatim}
X/
  Make.include Y/ Z/
X/Y/
  Make.include y.c
X/Z/
  Make.include z.c
\end{verbatim}
Where we build a library \verb+liby.a+ in \verb+Y/+ which is needed to
compile the program \verb+z+ in \verb+Z/+.  The contents of
\verb+X/Make.include+ is
\begin{verbatim}
$(eval $(call Include, $/Y/ $/Z/))
\end{verbatim}
and the contents of \verb+Y/Make.include+ is
\begin{verbatim}
$/.C_SRCS :=$/y.c
$/.C_LIBS :=$/liby.a
$/liby.a: $/y.o
\end{verbatim}
Then a natural choice for \verb+Z/Make.include+ would be
\begin{verbatim}
${Y/}  :=$/../Y/
$/.C_SRCS :=$/z.c
$/.C_EXES :=$/z
$/z: $/z.o ${Y/}liby.a
\end{verbatim}
If \verb+liby.a+ is already built by the time \verb+z+ is being
built, then there is no problem.  If not then, if the build
is invoked in \verb+Z/+, one will get some error about not
knowing how to build \verb+../Y/liby.a+, which is to be expected.
However, if the build is invoked in \verb+X/+ then one gets
a similar error about not knowing how to build \verb+X/../Y/liby.a+.
The build, invoked from \verb+X/+, does know how to build \verb+Y/liby.a+,
but does not understand that \verb+X/../Y/liby.a+ is the same thing.

The function
\begin{verbatim}
$(call MakePath,P)
\end{verbatim}
takes a path \verb+P+ to an existing directory
and returns the shortest (redundant dots and
double dots collapsed) path to \verb+P+, in a fashion
consistent with the pathname conventions used elsewhere
in the build system
(trailing '/' and '.' referred to by an empty string).

Thus, the right version of the \verb+Z/Make.include+ file is,
\begin{verbatim}
${Y/}  :=$(call MakePath,$/../Y/)
$/.C_SRCS :=$/z.c
$/.C_EXES :=$/z
$/z: $/z.o ${Y/}liby.a
\end{verbatim}
\verb+MakePath+ will issue a warning if the directory sought
is not found, and return an empty string.

The current implementation of the \verb+MakePath+ function is kind of
kludgey, involving a shell-call to either a C program or a PERL
program.  I have not found a better implementation yet for this
functionality.

\subsection{Legacy builds}

It is inevitable, because some parts of the code tree
came from external sources or are complicated legacy codes, that one
wants to still be able to integrate the usual {\em recursive make}
procedure for some directory which circumvents the build system
and its dependency checking.

Here is an example of a simple \verb+Make.include+ which does this.
\begin{verbatim}
$(eval $(call MakeRecursive))

$/md5lib/md5c.o: $/.all

$/.all:
        cd `dirname $@` && ${MAKE} all

$/.real-clean $/.clean:
        cd `dirname $@` && ${MAKE} clean

$/.install:
\end{verbatim}
The first line calls a special build system function,
\verb+MakeRecursive+ which declares that this \verb+Make.include+ file
is opting out of the usual build system and will define its own
subtargets.  The next line announces a target being supplied by this
build, the \verb+$/md5lib/md5c.o+ object file.  This is optional, but
gives the build system some idea of how to order multiple recursive
makes based on possible mutual dependencies.  The next lines specify
rules for subdirectory specific subtargets (\verb+all+, \verb+clean+,
\verb+real-clean+, \verb+install+) all of which are mandatory for
recursive \verb+Make.include+'s.  Each of these rules is just a
recursive build invocation after changing into the appropriate
directory, or an empty rule, signifying no action.

\section{Anatomy of the Makefile}

Here we go line by line through the \verb+Makefile+ and discuss the function
of every part.

\begin{verbatim}
default:   all
\end{verbatim}
First a default target is created.  The first goal listed is always
the default target.  Typically people use \verb+all+ for this.  Since
we do not know what verb+all+ will mean until much later in the file,
we can not define \verb+all+ yet.

\begin{verbatim}
ifndef MAKEFILE/
  MAKEFILE/ :=$(dir $(firstword $(MAKEFILE_LIST)))
endif
\end{verbatim}
Some files are looked for in the directory where the
\verb+Makefile+ was found, by extracting this information from the
built-in variable \verb+MAKEFILE_LIST+.  The \verb+MAKEFILE/+ variable
thus created should then point to the place where \verb+Make.compilers+
and \verb+Make.rules+ can be found.

\begin{verbatim}
ifdef MAKE_COMPILERS
 include ${MAKE_COMPILERS}
else
 include ${MAKEFILE/}Make.compilers
endif
\end{verbatim}
We load the \verb+Make.compilers+ file, which is more of a
configuration file, since it contains definitions not just of the
compilers but also of basic utilities.  One design goal was to have
all architectural dependencies captured by a single file so
that porting to a new architecture would require only the adjustment
of this file.  This file can be overridden by a user supplied
\verb+MAKE_COMPILERS+ argument, though it is probably a mistake
to use this feature as anything but a temporary device.

\begin{verbatim}
include ${MAKEFILE/}Make.path
\end{verbatim}
The \verb+Make.path+ file supplies a crucial utility in canonicalizing
directory names.

We now begin the directory traversal part, where subdirectories are
explored and build information is collected.

\begin{verbatim}
//           :=
/            :=
//-RECURSIVE    :=
define MakeRecursive
//-RECURSIVE :=$$/.
endef
\end{verbatim}
Three important variables are being initialized here.  The variable
\verb+//+ holds the list of all directories which have been traversed
and also have not opted out of the build system.  The directories are
kept in {\em dotted} form (i.e. \verb+.+, \verb+subdir/.+).  The
\verb+//-RECURSIVE+ variable holds those directories (in dotted form)
which have been traverse and have opted out of the build system.  The
variable \verb+/+ is the current relative path variable, which is
meant to be used by traversed \verb+Make.include+ files.

\begin{verbatim}
define Include
 $(foreach x,$(strip ${1}),$(call Include_File,$x))
endef

define Include_File
  ifeq ($(filter ${1}.,${WITHOUT_}),)
    ifeq ($(wildcard ${1}Make.include),${1}Make.include)
      $/.SUBS +=${1}.
      // +=${1}.
      ${1}.SUBS :=
      /  :=${1}
      include ${1}Make.include
      /  :=$/
    endif
  endif

endef

ifndef WITHOUT
  WITHOUT:=
endif
WITHOUT_:=$(patsubst %,%.,$(strip ${WITHOUT}))
\end{verbatim}
The normal \verb+include+ syntax is wrapped in a function which will
maintain \verb+/+ properly while adding newly traversed directories to
\verb+//+ and keeping track of who is who's children (kept in
\verb+$/.SUBS+).  Each directory
is traverse if its \verb+Make.include+ file exists and is not on
a set of special suppressed directories.  Traversed directories
have their \verb+Make.include+ files included.  Within those
\verb+Make.include+ files, \verb+/+ will hold the relative path
to the directory.  The \verb+Include+ function is meant for external
use, while the \verb+Include_File+ is a technicality and should not
be employed except within this file.

\begin{verbatim}
$(eval $(call Include_File,$/))
\end{verbatim}
We include the \verb+Make.include+ file which sits in the {\em current}
directory (as opposed to the build directory).  Since traversal
starts in the current directory, the only build information which
will be considered is that from this directory and its children.
This allows a user to build within their source directory, if they
do not which to check lateral dependencies for some reason (e.g.
efficiency).

\begin{verbatim}
//            :=$(filter-out ${//-RECURSIVE},${//})
\end{verbatim}
After traversal, \verb+//+ holds all directories which have been
traverse.  We now remove from it all those paths which have opted
out.  At this point, \verb+//+ holds those directories which are
considered to be properly participating in the build and
\verb+//-RECURSIVE+ holds those which will be built in a more or less
{\em legacy} fashion.  At this point, \verb+/+ should be an
empty string (even though it does appear below).

A second design goal was the separation of the specification of
build rules from the primary \verb+Makefile+ so that new file types
and build commands could be added to the build system by appending
them to \verb+Make.rules+.

\begin{verbatim}
__SUBGOALS__=
__DEPGOALS__=
\end{verbatim}
The \verb+__SUBGOALS__+ variable is intended to hold all those targets
which must be made for the \verb+all+ target.  The \verb+__DEPGOALS__+
holds patterns for dependency files which are to be included.
These variables will be
dynamically scoped (the one exception we make to the usual static scoping).
This allows for a variable capture which we exploit later.  The
\verb+__SUBGOALS__+ and \verb+__DEPGOALS__+ variables are
determined in the \verb+Make.rules+
file.

\begin{verbatim}
-include ${MAKEFILE/}Make.rules
\end{verbatim}
If the \verb+Make.rules+ file exists in the directory of the 
\verb+Makefile+ then it is included.  If it does not exist, the system will
use the default rules built-in to \verb+make+, which have a
chance of working right.

\begin{verbatim}
$(eval DEPENDS:=$(foreach x,${//},$(call __DEPGOALS__,$x)))
ifneq ($(strip ${DEPENDS}),)
  ifeq ($(filter %-clean,${MAKECMDGOALS}),)
    include ${DEPENDS}
  endif
endif
\end{verbatim}
The \verb+__DEPGOALS__+ pattern is evaluated on every directory and
expanded into a set of files in the variable \verb+DEPENDS+.  Unless
one of the command goals of the build contains the suffix \verb+-clean+,
these files will be included.  The {\em clean} conditional exists to
prevent certain kind of wedged conditions the build system could get
in as well as allowing the clean targets to be processed without a
building of any automatically created \verb+DEPENDS+ files.

We now define the standard make targets, which are applied to all
subdirectory targets.  The basic target, \verb+TARG+ is also defined
on a per-subdirectory basis with targets of the form \verb+$/.TARG+
with \verb+TARG+ being nearly an alias for \verb+.TARG+ (aside from
\verb+//-RECURSIVE+ directories).  This allows
the user to selectively build only those subgoals which are in a
single directory.  Target \verb+TARG+ for \verb+//-RECURSIVE+ builds are
done before the \verb+$/.TARG+ target.  Building all legacy targets
first seems like a good idea.

\begin{verbatim}
clean:         ${//-RECURSIVE:.=.clean}      $/.clean
define .RULE-clean
${1:.=.clean}: $${${1:.=.SUBS}:.=.clean}
	${RM} $${${1:.=.CLEAN}} ${__SUBGOALS__}
	(cd $1 && ${RM} -r ${C_TMP_COMPILE} ${CXX_TMP_COMPILE})

endef
$(eval $(foreach x,${//},$(call .RULE-clean,$x)))
\end{verbatim}
The \verb+clean+ target executes for recursive directories first
and then for \verb+.clean+.  The \verb+$/.clean+ target for
each subdirectory depends on the \verb+$/.clean+ target of its
children and executes by removing those files or patterns which were listed
in the \verb+$/.CLEAN+ variable of that directory, any subgoals of
that directory, and any temporary compiler files which may have been
created in that directory (e.g. \verb+so_locations/+).

\begin{verbatim}
depends-clean:                            $/.depends-clean
${//-RECURSIVE:.=.depends-clean}:
define .RULE-depends-clean
${1:.=.depends-clean}: $${${1:.=.SUBS}:.=.depends-clean}
	${RM} ${1:.=Make.depends} ${__DEPGOALS__}

endef
$(eval $(foreach x,${//},$(call .RULE-depends-clean,$x)))
\end{verbatim}
Similar to \verb+clean+ only we remove only dependency files which
may have been built to satisfy the \verb+include ${DEPENDS}+ line
previous.

\begin{verbatim}
real-clean:    ${//-RECURSIVE:.=.real-clean} $/.real-clean
define .RULE-real-clean
${1:.=.real-clean}: $${${1:.=.SUBS}:.=.real-clean}
	${RM} $${${1:.=.CLEAN}} ${__SUBGOALS__}
	(cd $1 && ${RM} -r ${C_TMP_COMPILE} ${CXX_TMP_COMPILE})
	${RM} ${1:.=Make.depends} ${__DEPGOALS__}
	${RM} $${${1:.=.REAL-CLEAN}}

endef
$(eval $(foreach x,${//},$(call .RULE-real-clean,$x)))
\end{verbatim}
A combination of the previous two \verb+clean+ targets.

\begin{verbatim}
all:           ${//-RECURSIVE:.=.all}        $/.all
define .RULE-all
${1:.=.all}: $${${1:.=.SUBS}:.=.all} ${__SUBGOALS__}

endef
$(eval $(foreach x,${//},$(call .RULE-all,$x)))
\end{verbatim}
The \verb+all+ target depends on all subdirectory \verb+all+'s
and all subgoals for this directory.


The last major section of the \verb+Makefile+ is the installer.
Installation currently proceeds by depending on the subgoals
and doing a copy of those built subgoals to a special directory,
\verb+INSTALL/+ which is determined in the \verb+Make.compilers+
file.  Because different directories may wish to do different
kinds of pre and post installation actions, the \verb+.install+
targets have been written to provide a number of hooks.  It is
up to the \verb+Make.rules+ file to make use of those hooks.

\begin{verbatim}
${//-RECURSIVE:.=.install-copy}:
define .RULE-install-copy
${1:.=.install-copy}: $${${1:.=.SUBS}:.=.install-copy}

endef
$(eval $(foreach x,${//},$(call .RULE-install-copy,$x)))
\end{verbatim}
All \verb+.install+ targets have a \verb+.install-copy+ target defined
which depends on the \verb+.install-copy+'s of the children.  A dummy
target is defined for legacy builds to prevent certain kinds of
build problems, but it is never normally invoked.

\begin{verbatim}
install:       ${//-RECURSIVE:.=.install}    $/.install
define .RULE-install
${1:.=.install}: ${1:.=.all} ${1:.=.install-copy}

endef
$(eval $(foreach x,${//},$(call .RULE-install,$x)))
\end{verbatim}
An install in a directory is equivalent to doing an install in
the legacy directories, a build in the current directory (and
its children) and an install copy in the current directory
(and its children).

\section{Anatomy of the Make.rules}
% cvs revision 1.25

The execution of commands other than cleaning commands is
determined by the file \verb+Make.rules+.  This file defines
file types and actions to be taken to rebuild files.

\begin{verbatim}
define .FUN-install-copy
	@ files='$$(strip $1)'; dirs='$$(strip $2)'; \
	if [ -n "$$$${files}" -a -n "$$$${dirs}" ] ; then \
	  for F in $$$${files} ; do \
	    if [ -f $$$${F} ] ; then \
	      for D in $$$${dirs} ; do \
	        Fout=$${INSTALL/}$$$${D}`basename $$$${F}` ; \
	        echo ":Copying $$$${F} to $$$${Fout}:" ; \
	        mkdir -p `dirname $$$${Fout}` && \
	        rm -f $$$${Fout} && cp -fp $$$${F} $$$${Fout} ; \
	      done ; \
	    fi ; \
	  done ; \
        fi
endef
define .FUN-install-copy-script
	@ files='$$(strip $1)'; dirs='$$(strip $2)'; sheb='$$(strip $3)'; \
	if [ -n "$$$${files}" -a -n "$$$${dirs}" ] ; then \
	  for F in $$$${files} ; do \
	    if [ -f $$$${F} ] ; then \
	      for D in $$$${dirs} ; do \
	        Fout=$${INSTALL/}$$$${D}`basename $$$${F}` ; \
	        echo ":Mangling $$$${F} to $$$${Fout}:" ; \
	        mkdir -p `dirname $$$${Fout}` && \
	        rm -f $$$${Fout} && cp -fp $$$${F} $$$${Fout} ; \
	        chmod ugo+x $$$${Fout} && \
	        ${PERL} -npi \
	           -e"if(0==\$$$$i++){s|^#!.*|#! $$$${sheb}|}" $$$${Fout}; \
	      done ; \
	    fi ; \
	  done ; \
        fi
endef
\end{verbatim}
These are two helper functions.  The first of these installs is first
argument, \verb+files+, into all of the directories specified in the
second argument, \verb+dirs+ (which are assumed to be subdirs of
\verb+INSTALL/+).  It checks for existence and tries to make
direectories which need making.  The second function is similar to the
first, but it also takes a third argument \verb+sheb+ which is the
{\em shebang} line for a script.  It replaces the shebang line of the
contents of the \verb+sheb+ variable.

The rest of the file is the set of blocks, each block dealing with
a certain file type and its rules.

The first section, which is the largest is the one for C and C++.
\begin{verbatim}
__DEPGOALS__     +=                 $$(patsubst %,%.d,$${${1:.=.C_SRCS}})
ALL_C_DEPS       :=$(foreach x,${//},$(patsubst %,%.d,${${x:.=.C_SRCS}}))
${ALL_C_DEPS}:%.d:%
	@ echo "making $@"
	 dir=`echo $< | sed -e's~[^/]*$$~~'`; \
	  ${CCDEP} ${CDEPFLAGS} ${CFLAGS} $< | \
	  sed -e"/:/s!^!$${dir}!" > $@

__DEPGOALS__     +=                 $$(patsubst %,%.d,$${${1:.=.CXX_SRCS}})
ALL_CXX_DEPS     :=$(foreach x,${//},$(patsubst %,%.d,${${x:.=.CXX_SRCS}}))
${ALL_CXX_DEPS}:%.d:%
	@ echo "making $@"
	 dir=`echo $< | sed -e's~[^/]*$$~~'`; \
	  ${CXXDEP} ${CXXDEPFLAGS} ${CXXFLAGS} $< | \
	  sed -e"/:/s!^!$${dir}!" > $@
\end{verbatim}
This section specifies the compiler dependencies which must be
detected.  Dependency files are made for all source files
(set to \verb+$/.C_SRCS+ and \verb+$/.CXX_SRCS+ presumably in
the \verb+$/Make.include+ file).  These
names are added to the \verb+___DEPGOALS__+ to be included later
in the \verb+Makefile+.  We also have the rule for constructing
dependency files from source files.

\begin{verbatim}
.PRECIOUS: %.o

%.o: %.c
	${CC} ${CFLAGS} ${CFLAGS_COMPILE} -o $@ -c $<

%.o: %.cc
	${CXX} ${CXXFLAGS} ${CXXFLAGS_COMPILE} -o $@ -c $<

%.o: %.cpp
	${CXX} ${CXXFLAGS} ${CXXFLAGS_COMPILE} -o $@ -c $<

%.o: %.C
	${CXX} ${CXXFLAGS} ${CXXFLAGS_COMPILE} -o $@ -c $<
\end{verbatim}
Pattern-driven rules are specified for several kinds of
object code builds.

\begin{verbatim}
ALL_C_EXES   :=$(strip $(foreach x,${//},${${x:.=.C_EXES}}))
${ALL_C_EXES}:
	${CC} ${CLDFLAGS} -o $@ $^ ${CLIBS}
__SUBGOALS__+=$${${1:.=.C_EXES}}

ALL_CXX_EXES :=$(strip $(foreach x,${//},${${x:.=.CXX_EXES}}))
${ALL_CXX_EXES}:
	${CXX} ${CXXLDFLAGS} -o $@ $^ ${CXXLIBS}
__SUBGOALS__+=$${${1:.=.CXX_EXES}}
\end{verbatim}
We add to the subgoals the executable programs \verb+$/.C_EXES+ and
\verb+$/.CXX_EXES+.  They are constructed by a link command.

\begin{verbatim}
define .RULE-install-copy-C-CXX-EXES
${1:.=.install-copy}: ${1:.=.install-copy-C-CXX-EXES}
${1:.=.install-copy-C-CXX-EXES}:
# all exes go to bin
	$(call .FUN-install-copy,$${${1:.=.C_EXES}} $${${1:.=.CXX_EXES}},bin/)

endef
$(eval $(foreach x,${//},$(call .RULE-install-copy-C-CXX-EXES,$x)))
\end{verbatim}
We add to each \verb+.install-copy+ rule the action that executable
programs be copied to the subdirectory \verb+bin/+.

\begin{verbatim}
ALL_C_LIBS   :=$(strip $(foreach x,${//},${${x:.=.C_LIBS}}))
${ALL_C_LIBS}:
	${RM} $@ && ${AR} ${ARFLAGS} $@ $^
__SUBGOALS__+=$${${1:.=.C_LIBS}}

ALL_CXX_LIBS     :=$(strip $(foreach x,${//},${${x:.=.CXX_LIBS}}))
${ALL_CXX_LIBS}:
	${RM} $@ && ${AR} ${ARFLAGS} $@ $^
__SUBGOALS__+=$${${1:.=.CXX_LIBS}}

${_OS_}_SHLIB_FLAGS:=
ALL_C_SHLIBS     :=$(strip $(foreach x,${//},${${x:.=.C_SHLIBS}}))
${ALL_C_SHLIBS}:
	${RM} $@ && ${C} ${CFLAGS} ${SHLIB_FLAGS} ${${_OS_}_SHLIB_FLAGS} -o $@ $^ ${CLIBS}

ALL_CXX_SHLIBS   :=$(strip $(foreach x,${//},${${x:.=.CXX_SHLIBS}}))
${ALL_CXX_SHLIBS}:
	${RM} $@ && ${CXX} ${CXXFLAGS} ${SHLIB_FLAGS} ${${_OS_}_SHLIB_FLAGS} -o $@ $^ ${CXXLIBS}
__SUBGOALS__+=$${${1:.=.C_SHLIBS}} $${${1:.=.CXX_SHLIBS}}
\end{verbatim}
Additional C,C++ subgoals include libraries and shared libraries.  It is
unfortunate that AIX has a fairly different means of producing shared
libraries than other operatin systems.  This is the only place in the
rules where the OS is a factor in determining the rule.  If more situations
like this arise, it may be necessary to redesign the interactions
between \verb+Make.rules+ and \verb+Make.compilers+.

\begin{verbatim}
define .RULE-install-copy-C-CXX-LIBS
${1:.=.install-copy}: ${1:.=.install-copy-C-CXX-LIBS}
${1:.=.install-copy-C-CXX-LIBS}:
# all libs go to lib/${.LIB/}
	$(call .FUN-install-copy,$${${1:.=.C_LIBS}} $${${1:.=.CXX_LIBS}}, \
                                 lib/$${${1.=.LIB/}})

endef
$(eval $(foreach x,${//},$(call .RULE-install-copy-CXX-LIBS,$x)))

define .RULE-install-copy-C-CXX-SHLIBS
${1:.=.install-copy}: ${1:.=.install-copy-CXX-SHLIBS}
${1:.=.install-copy-CXX-SHLIBS}:
# all shlibs go to lib/${.LIB/}
	$(call .FUN-install-copy,$${${1:.=.C_SHLIBS}} $${${1:.=.CXX_SHLIBS}}, \
                                 lib/$${${1.=.LIB/}})

endef
$(eval $(foreach x,${//},$(call .RULE-install-copy-CXX-SHLIBS,$x)))
\end{verbatim}
Libraries and shared libraries are copied to the subdirectory
\verb+lib/$/.LIB/+, i.e. to \verb+lib/+ or some subdirectory of
\verb+lib/+ specified by the  variable \verb+$/.LIB/+, which is
presumably set in the \verb+$/Make.include+.

\begin{verbatim}
define .RULE-install-copy-C-CXX-INCS
${1:.=.install-copy}: ${1:.=.install-copy-C-CXX-INCS}
${1:.=.install-copy-C-CXX-INCS}:
# all includes go to include/${.INCLUDE/}
	$(call .FUN-install-copy,$${${1:.=.C_INCS}} $${${1:.=.CXX_INCS}}, \
                                 include/$${${1:.=.INCLUDE/}})

endef
$(eval $(foreach x,${//},$(call .RULE-install-copy-C-CXX-INCS,$x)))
\end{verbatim}
If include files are defined in \verb+$/.C_INCS+ or \verb+$/.CXX_INC+
then these are copied directly to \verb+include/+ or one of its
subdirectories, specified by \verb+$/.INCLUDE/+.

We now start on the section which builds ps and pdf documents from
\LaTeX files.
\begin{verbatim}
.PRECIOUS: %.pdf %.ps %.dvi %.aux %.bbl

%.dvi: %.tex
	cd `dirname $<` && ${LATEX} `basename $<` && ${LATEX} `basename $<`

%.aux: %.tex
	cd `dirname $<` && ${LATEX} `basename $<` && ${LATEX} `basename $<`

%.bbl: %.aux
	cd `dirname $<` && ${BIBTEX} `basename ${<:.aux=}`
\end{verbatim}
These are the commands to invoke \LaTeX, based on file pattern.

\begin{verbatim}
ALL_TEX_PS    :=$(strip $(foreach x,${//},${${x:.=.TEX_PS}}))
ALL_TEX_PDF   :=$(strip $(foreach x,${//},${${x:.=.TEX_PDF}}))

${ALL_TEX_PS}: %.ps: %.dvi
	cd `dirname $<` && ${DVIPS} -o `basename $@` `basename $<`

${ALL_TEX_PDF}: %.pdf: %.ps
	${PS2PDF} $< $@

__SUBGOALS__+=$${${1:.=.TEX_PS}} $${${1:.=.TEX_PDF}}
\end{verbatim}
The \verb+$/.TEX_PS+ and \verb+$/.TEX_PDF+ files are added to the
subgoals.  The commands to actually construct ps and pdf files 
have been defined.

\begin{verbatim}
define .RULE-install-copy-TEX_PSPDF
${1:.=.install-copy}: ${1:.=.install-copy-TEX_PSPDF}
${1:.=.install-copy-TEX_PSPDF}:
	$(call .FUN-install-copy,$${${1:.=.TEX_PS}},doc/$${${1:.=.DOC/}})
	$(call .FUN-install-copy,$${${1:.=.TEX_PDF}},doc/$${${1:.=.DOC/}})

endef
$(eval $(foreach x,${//},$(call .RULE-install-copy-TEX_PSPDF,$x)))
\end{verbatim}
The ps and pdf files are copied to \verb+doc/+ or the
\verb+$/.DOC/+ subdirectory of \verb+doc/+.

\begin{verbatim}
define .RULE-install-copy-PYTHON
${1:.=.install-copy}: ${1:.=.install-copy-PYTHON}
${1:.=.install-copy-PYTHON}:
	$(call .FUN-install-copy-script,$${${1:.=.PY_EXES}},\
                                         scripts/,\
                                         ${PYSHEBANG})
	$(call .FUN-install-copy,$${${1:.=.PY_LIBS}}, \
                                 scripts/$${${1:.=.PY_LIB/}})

endef
$(eval $(foreach x,${//},$(call .RULE-install-copy-PYTHON,$x)))
\end{verbatim}
Python scripts require only copying, but with the shebang mangling
on the \verb+$/.PY_EXES+ files.  The \verb+$/.PY_EXES+ files get
copied (and shebang-ed) to \verb+scripts/+, and the
\verb+$/.PY_LIBS+ get copied to \verb+lib/$/.PY_LIB/+.

\section{Anatomy of Make.compilers}

The \verb+Make.compilers+ file sets many architecture dependent
variables as well as compiling modes such as debugging or profiling.
Additionally, the paths for various libraries and utilities are set.
The first part of the file ascertains the architecture and build mode,
and the rest of the file sets variables based on them.  This is done
in sections broken down by application rather than architecture or
mode.  This will not be a line by line walkthrough.  Instead we will
list important variables being set and what they mean for the other
parts of the build system.

\begin{verbatim}
_OS_:=$(shell uname)
ifdef OPERATING_SYSTEM
  _OS_:=$(OPERATING_SYSTEM)
else
  WITH_GNU:=1
endif

_CC_:=
ifdef WITH_GNU
  _CC_:=-gcc
endif

_OPT_:=
ifeq (WITH_OPT,debug)
  _OPT_ :=-debug
endif
ifeq (WITH_OPT,profile)
  _OPT_ :=-prof
endif

_THR_:=
ifdef WITH_THREADS
  _THR_:=-threaded
endif
\end{verbatim}
\verb+_OS_+ holds the architecture.  If \verb+_CC_+ is set to '-gcc'
then GNU compilers will be used, and if it is empty and native
compilers will be used if the \verb+_OS_+ is known (otherwise GNU
will be used).  There are three \verb+_OPT_+ modes: 'debug', 'profile',
and '' (normal).  There is also a \verb+_THR_+ variable which determines
if the applications are to be compiled with threading.  A user wishing
to build with profiling and threading enabled would do something like
\begin{verbatim}
$ gmake WITH_OPT=profile WITH_THREADS=1
\end{verbatim}
to turn these options on.

\begin{verbatim}
ifdef INSTALL_TAG
  INSTALL/:=${MAKEFILE/}${_OS_}${_CC_}${_OPT_}${_THR_}-${INSTALL_TAG}/
else
  INSTALL/:=${MAKEFILE/}${_OS_}${_CC_}${_OPT_}${_THR_}/
endif
\end{verbatim}
The \verb+INSTALL/+ directory is set.  It is based on the location
of the \verb+Makefile+ and the given tags.
If the user has defined a the variable \verb+INSTALL_TAG+ than this
will be added to the \verb+INSTALL/+ directory.

\begin{verbatim}
CCDEP		 :=gcc
CXXDEP		 :=g++
CDEPFLAGS        :=-MM -MG
CXXDEPFLAGS      :=-MM -MG
\end{verbatim}
The GNU compilers have much more sophisticated dependency producers than
the native compilers, so we will use them for all architectures.  In
theory this could cause bugs due to the mismatch between depends and
build compilers.  In practise, it does not.

\begin{verbatim}
CC:=
CXX:=
CFLAGS:=
CXXFLAGS:=
CFLAGS_COMPILE:=
CXXFLAGS_COMPILE:=
CLDFLAGS:=
CXXLDFLAGS:=
CLIBS:=-lm
CXXLIBS:=-lm
SHLIB_FLAGS:=
\end{verbatim}
The \verb+CC,CXX+ variables are obvious.  The \verb+CFLAGS,CXX_FLAGS+
variables are those compile flags which are needed by bith the
dependency check and by the actual compile such as
include paths.  The \verb+CFLAGS_COMPILE+
and \verb+CXXFLAGS_COMPILE+ flags are those which are only needed by
the actual compile, not by the dependency checker, like debugging
and profiling flags.  The \verb+CLDFLAGS,CXXLDFLAGS+ are the flags
for the compiler when functioning as a loader and are placed on
the loader command line ahead of the object files.  The
\verb+CLIBS,CXXLIBS+ are placed on the loader command line after the
object files.

The \verb+Make.compilers+ file is not just about defining the compilers
and interpreters on the system.  It is also used to make available certain
architecture dependent package locations.
\begin{verbatim}
ifeq (${_OS_},TRU64)
  CXXFLAGS_LAPACK   :=-DFTN_UNDERSCORE -DFTN_LOWERCASE
  CXXLDFLAGS_LAPACK :=
  CXXLIBS_LAPACK    :=-ldxml
endif
ifeq (${_OS_},AIX)
  CXXFLAGS_LAPACK   :=-DFTN_LOWERCASE
  CXXLDFLAGS_LAPACK :=-L/usr/local/ir/lib
  CXXLIBS_LAPACK    :=-llapack -lessl -lxlf90
endif
\end{verbatim}
Some modules use LAPACK.  Although these variables do not get used
in any of the rules of the build system, we define them in 
\verb+Make.compilers+ so that they can be used in the various
\verb+Make.include+ files which need LAPACK.

\begin{verbatim}
PYTHON    :=$(shell which python)
PYTHON_FLAGS :=
PYINC     :=
PYSHEBANG :=${PYTHON}
ifeq (${_OS_}${_CC_},TRU64)
  PYINC     :=-I/usr/local/ir/Python-2.2.2 -I/usr/local/ir/Python-2.2.2/Include
  PYTHON    :=/usr/local/ir/bin/python
  PYSHEBANG :=${PYTHON} ${PYTHON_FLAGS}
endif
ifeq (${_OS_}${_CC_},AIX)
  PYINC   :=-I/usr/local/include/python2.2
  PYTHON  :=/usr/local/bin/python
  PYSHEBANG :=${PYTHON} ${PYTHON_FLAGS}
endif
\end{verbatim}
Python and its paths for the known architectures are determined here.  On
unknown architectures we guess where python is based on the users path.


\end{document}

